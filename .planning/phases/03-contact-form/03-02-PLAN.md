---
phase: 03-contact-form
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - convex/convex.config.ts
  - convex/contact.ts
  - components/contact/ContactForm.tsx
autonomous: false

must_haves:
  truths:
    - Visitor can submit contact form and data persists in Convex database
    - Rapid repeated submissions are blocked by rate limiting
    - Bot submissions are silently rejected via honeypot detection
    - Visitor sees success message after successful submission
    - Visitor sees clear error message if submission fails
  artifacts:
    - path: convex/convex.config.ts
      provides: Rate limiter component registration
      contains: "app.use(rateLimiter)"
    - path: convex/contact.ts
      provides: Submit mutation with validation, honeypot check, and rate limiting
      exports: [submit]
      min_lines: 60
    - path: components/contact/ContactForm.tsx
      provides: Integration with Convex submit mutation
      contains: "useMutation(api.contact.submit)"
  key_links:
    - from: components/contact/ContactForm.tsx
      to: convex/contact.ts
      via: useMutation hook
      pattern: "api\\.contact\\.submit"
    - from: convex/contact.ts
      to: convex/schema.ts
      via: database insert
      pattern: 'ctx\\.db\\.insert\\("contactSubmissions"'
    - from: convex/contact.ts
      to: "@convex-dev/ratelimiter"
      via: rate limiter check
      pattern: "rateLimiter\\.limit"

user_setup:
  - service: convex-dev
    why: Rate limiting component for spam protection
    env_vars: []
    dashboard_config:
      - task: "Install @convex-dev/ratelimiter component"
        location: "Run: npm install @convex-dev/ratelimiter"
---

<objective>
Implement contact form backend with spam protection and data persistence.

Purpose: Complete the contact form by adding Convex mutation that validates input, blocks spam via honeypot and rate limiting, and stores legitimate submissions in the database.

Output: Fully functional contact form that accepts valid submissions, rejects spam, enforces rate limits, and provides clear feedback to users.
</objective>

<execution_context>
@D:\Projects\saad-portfolio\.claude\get-shit-done\workflows\execute-plan.md
@D:\Projects\saad-portfolio\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@D:\Projects\saad-portfolio\.planning\PROJECT.md
@D:\Projects\saad-portfolio\.planning\ROADMAP.md
@D:\Projects\saad-portfolio\.planning\STATE.md
@D:\Projects\saad-portfolio\.planning\REQUIREMENTS.md
@D:\Projects\saad-portfolio\.planning\phases\03-contact-form\03-RESEARCH.md
@D:\Projects\saad-portfolio\.planning\phases\03-contact-form\03-01-SUMMARY.md

# Codebase context
@D:\Projects\saad-portfolio\convex\schema.ts
@D:\Projects\saad-portfolio\lib\validations\contact.ts
@D:\Projects\saad-portfolio\components\contact\ContactForm.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install rate limiter and configure Convex app</name>
  <files>
    package.json
    convex/convex.config.ts
  </files>
  <action>
1. **Install @convex-dev/ratelimiter:**
   ```bash
   npm install @convex-dev/ratelimiter
   ```

2. **Create or update `convex/convex.config.ts`:**
   - Import defineApp from "convex/server"
   - Import rateLimiter from "@convex-dev/ratelimiter/convex.config.js"
   - Create app with `const app = defineApp()`
   - Register rate limiter: `app.use(rateLimiter)`
   - Export default app

   Full file structure:
   ```typescript
   import { defineApp } from "convex/server";
   import rateLimiter from "@convex-dev/ratelimiter/convex.config.js";

   const app = defineApp();
   app.use(rateLimiter);

   export default app;
   ```

**Why separate config file:** Convex components must be registered in convex.config.ts for the framework to initialize them. Without this, rateLimiter will fail with component not found error.

**Critical:** This file MUST exist and register rateLimiter before the mutation can use it.
  </action>
  <verify>
```bash
npm list @convex-dev/ratelimiter
cat convex/convex.config.ts
npx convex dev
```
Should show rate limiter installed, config file with app.use(rateLimiter), and Convex dev server starting without errors.
  </verify>
  <done>
- @convex-dev/ratelimiter appears in package.json dependencies
- convex/convex.config.ts exists with defineApp and app.use(rateLimiter)
- Convex dev server starts successfully and recognizes rate limiter component
  </done>
</task>

<task type="auto">
  <name>Task 2: Create contact submission mutation with spam protection</name>
  <files>
    convex/contact.ts
  </files>
  <action>
Create `convex/contact.ts` with submit mutation:

1. **Imports:**
   - mutation from "./_generated/server"
   - v, ConvexError from "convex/values"
   - RateLimiter, MINUTE from "@convex-dev/ratelimiter"
   - components from "./_generated/api"

2. **Set up rate limiter:**
   ```typescript
   const rateLimiter = new RateLimiter(components.rateLimiter, {
     contactForm: {
       kind: "fixed window",
       rate: 3,        // 3 submissions
       period: MINUTE  // per minute
     },
   });
   ```
   **Why fixed window:** Simpler than token bucket for this use case. 3 per minute allows legitimate retry attempts while blocking spam.

3. **Create submit mutation:**
   - Args: name (v.string()), email (v.string()), message (v.string()), honeypot (v.string())
   - Handler implementation (4 defense layers):

   **Layer 1 - Honeypot check (bot detection):**
   ```typescript
   if (args.honeypot && args.honeypot.length > 0) {
     console.log("Honeypot triggered - bot detected");
     return { success: true }; // Fake success to not alert bot
   }
   ```
   **CRITICAL:** Do NOT throw error for honeypot - silently return fake success. If we throw, bots learn they were caught and adapt.

   **Layer 2 - Rate limiting (spam prevention):**
   ```typescript
   const limitKey = "anonymous"; // TODO: Use IP or session in production
   const { ok, retryAfter } = await rateLimiter.limit(
     ctx,
     "contactForm",
     { key: limitKey }
   );

   if (!ok) {
     throw new ConvexError({
       message: `Rate limit exceeded. Please try again in ${Math.ceil(retryAfter / 1000)} seconds.`,
     });
   }
   ```
   **Why "anonymous" key:** Convex mutations don't have direct access to request IP. In production, this would use IP from Next.js middleware or session ID. For now, global rate limit is acceptable for v1.

   **Layer 3 - Server-side validation (defense in depth):**
   - Check name length: 2-50 characters
   - Check email format: must contain "@" (simple check, real validation in Zod)
   - Check message length: 10-1000 characters
   - Throw ConvexError with descriptive message for each failure
   - **Why validate server-side:** Client validation can be bypassed. Server validation is security, client validation is UX.

   **Layer 4 - Store submission:**
   ```typescript
   await ctx.db.insert("contactSubmissions", {
     name: args.name,
     email: args.email,
     message: args.message,
     status: "new",
     submittedAt: new Date().toISOString(),
   });

   return { success: true };
   ```

4. **Error messages:**
   - Make error messages user-friendly but not too revealing
   - Don't expose implementation details to potential attackers
   - Rate limit message should tell user exactly when they can retry

**Full defense strategy:** Honeypot catches dumb bots (50%+), rate limiting prevents spam floods, server validation prevents malformed data, and only clean submissions reach database.
  </action>
  <verify>
```bash
cat convex/contact.ts
npx convex dev
```
Should show:
- Mutation exported with correct arg types
- Four defense layers in order: honeypot, rate limit, validation, insert
- Honeypot returns fake success (no throw)
- Rate limit uses ConvexError with retry time
- Database insert uses correct table name and fields from schema
  </verify>
  <done>
- convex/contact.ts exists with submit mutation exported
- Rate limiter configured for 3 submissions per minute (fixed window)
- Honeypot check silently returns fake success (doesn't alert bots)
- Rate limiting throws ConvexError with retry time on exceed
- Server-side validation checks name/email/message constraints
- Valid submissions stored in contactSubmissions table with "new" status
- Convex dev server compiles mutation without errors
- CONTACT-03 requirement satisfied: Form submits to Convex mutation for storage
- CONTACT-04 requirement satisfied: Honeypot field for spam protection
- CONTACT-05 requirement satisfied: Rate limiting prevents rapid submissions
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire ContactForm to Convex mutation</name>
  <files>
    components/contact/ContactForm.tsx
  </files>
  <action>
Update `components/contact/ContactForm.tsx` to integrate with Convex mutation:

1. **Add imports:**
   - useMutation from "convex/react"
   - api from "@/convex/_generated/api"
   - ConvexError from "convex/values"

2. **Replace stub onSubmit handler:**
   - Add at component top: `const submitContact = useMutation(api.contact.submit);`
   - Update onSubmit async function:
     ```typescript
     const onSubmit = async (data: ContactFormData) => {
       try {
         await submitContact({
           name: data.name,
           email: data.email,
           message: data.message,
           honeypot: data.website || "",
         });
         toast.success("Message sent successfully! I'll get back to you soon.");
         reset();
       } catch (error) {
         if (error instanceof ConvexError) {
           const msg = (error.data as { message: string }).message;
           toast.error(msg || "Failed to send message. Please try again.");
         } else {
           console.error("Unexpected error:", error);
           toast.error("An unexpected error occurred. Please try the email link below.");
         }
       }
     };
     ```

3. **Error handling strategy:**
   - ConvexError = application errors (rate limit, validation) - show user the message
   - Other errors = system errors (network, server down) - show generic message
   - Always log unexpected errors to console for debugging
   - Guide user to email fallback on unexpected errors

4. **Toast messages:**
   - Success: Reassure user message was received and set expectation for response
   - Rate limit: Show exact error from server (includes retry time)
   - Validation: Show specific validation failure
   - Unexpected: Direct user to alternative contact method

**Why distinguish error types:** ConvexError messages are safe to show users (we control them), but system errors might contain sensitive details or be confusing.
  </action>
  <verify>
```bash
cat components/contact/ContactForm.tsx | grep -A 20 "const onSubmit"
npm run dev
```
Test flow at http://localhost:3000/contact:
1. Submit valid form - should see success toast and form clear
2. Check Convex dashboard - submission should appear in contactSubmissions table
3. Submit 4 times rapidly - 4th should show rate limit error with retry time
4. Fill honeypot field via console (`document.querySelector('input[tabindex="-1"]').value = "spam"`) and submit - should show success but NOT save to database
  </verify>
  <done>
- ContactForm uses useMutation(api.contact.submit) to call backend
- onSubmit handler calls submitContact with name, email, message, and honeypot fields
- Error handling distinguishes ConvexError (shows user message) from system errors (generic message)
- Success toast shows reassuring message and form resets
- Rate limit errors display retry time from server
- Build succeeds with no TypeScript errors
- CONTACT-02 requirement satisfied: Form validation using zod schema (client + server)
- CONTACT-07 requirement satisfied: Success message shown after submission
- CONTACT-08 requirement satisfied: Loading state while form is submitting (from Plan 01)
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete contact form with spam protection, rate limiting, and Convex backend integration. All 8 CONTACT requirements are now implemented.
  </what-built>
  <how-to-verify>
**Test the complete contact form flow:**

1. **Start dev servers:**
   ```bash
   npm run dev          # Terminal 1
   npx convex dev       # Terminal 2
   ```

2. **Basic submission test:**
   - Visit http://localhost:3000/contact
   - Fill form with valid data (name, email, message)
   - Click "Send Message"
   - Expected: Success toast appears, form clears, submission appears in Convex dashboard

3. **Validation test:**
   - Try submitting with empty fields → Should see error messages
   - Enter short name (1 char) → Should see "Name must be at least 2 characters"
   - Enter invalid email → Should see "Please enter a valid email address"
   - Enter short message (5 chars) → Should see "Message must be at least 10 characters"
   - Errors should appear below each field in red

4. **Rate limiting test:**
   - Submit valid form successfully
   - Immediately submit again (3 more times)
   - On 4th submission within 1 minute → Should see "Rate limit exceeded. Please try again in X seconds"
   - Wait for time in error message, try again → Should succeed

5. **Honeypot test (bot detection):**
   - Open browser console
   - Fill form normally but run: `document.querySelector('input[tabindex="-1"]').value = "spam"`
   - Submit form
   - Expected: Success toast appears BUT check Convex dashboard - submission should NOT be saved
   - This proves honeypot silently rejects bots without alerting them

6. **Accessibility test:**
   - Use Tab key to navigate form
   - Labels should be announced by screen reader
   - Errors should be associated with fields (aria-describedby working)

7. **Loading state test:**
   - Submit valid form
   - During submission: button should show "Sending..." and be disabled
   - After success: button should return to "Send Message" and be enabled

8. **Verify data structure in Convex dashboard:**
   - Open Convex dashboard → Data → contactSubmissions table
   - Check that submissions have: name, email, message, status ("new"), submittedAt (ISO date)
   - Verify honeypot submissions do NOT appear

**Visual check:**
- Form styling matches dark theme aesthetic of rest of site
- Error messages are clearly visible but not jarring
- Email fallback link is present below form
- Toast notifications appear in bottom-right corner with dark styling

**Requirements coverage check:**
- [x] CONTACT-01: Form with name, email, message fields
- [x] CONTACT-02: Form validation using zod schema
- [x] CONTACT-03: Form submits to Convex mutation
- [x] CONTACT-04: Honeypot field for spam protection
- [x] CONTACT-05: Rate limiting prevents rapid submissions
- [x] CONTACT-06: Email fallback link visible
- [x] CONTACT-07: Success message after submission
- [x] CONTACT-08: Loading state while submitting
  </how-to-verify>
  <resume-signal>
Type "approved" if all tests pass, or describe any issues found for revision.
  </resume-signal>
</task>

</tasks>

<verification>
**Integration checks:**
1. ContactForm successfully calls Convex mutation via useMutation
2. Honeypot submissions return fake success but don't save to database
3. Rate limiting enforces 3 submissions per minute limit
4. Valid submissions save to contactSubmissions table with correct schema
5. Error messages from ConvexError are displayed in user-friendly toasts
6. Form resets and shows success after valid submission

**Data integrity checks:**
1. Check Convex dashboard - contactSubmissions table has entries with all required fields
2. Submissions have status "new" for admin panel filtering (Phase 4)
3. submittedAt timestamps are in ISO format
4. Honeypot catches don't pollute database

**Security checks:**
1. Server-side validation prevents invalid data even if client validation is bypassed
2. Rate limiting prevents spam floods
3. Honeypot catches basic bots without alerting them
4. Error messages don't expose implementation details
</verification>

<success_criteria>
- [ ] @convex-dev/ratelimiter installed in package.json
- [ ] convex/convex.config.ts exists and registers rate limiter component
- [ ] convex/contact.ts exports submit mutation with 4 defense layers
- [ ] Honeypot check silently returns fake success (no throw or database insert)
- [ ] Rate limiting throws ConvexError with retry time when limit exceeded
- [ ] Server-side validation checks all fields before database insert
- [ ] Valid submissions save to contactSubmissions table with status "new"
- [ ] ContactForm uses useMutation to call api.contact.submit
- [ ] Error handling distinguishes ConvexError from system errors
- [ ] Success flow: toast + form reset after valid submission
- [ ] All 8 CONTACT requirements (CONTACT-01 through CONTACT-08) are satisfied
- [ ] Human verification passes: form works, spam protection blocks bots/floods, data persists
</success_criteria>

<output>
After completion, create `.planning/phases/03-contact-form/03-02-SUMMARY.md` documenting:
- Rate limiter configuration (fixed window, 3/min)
- Four defense layers: honeypot, rate limit, validation, insert
- Honeypot strategy: fake success to avoid alerting bots
- Error handling approach: ConvexError vs system errors
- Known limitation: rate limit key is "anonymous" (not IP-based) for v1
- All 8 CONTACT requirements completed
- Next phase: Authentication & Admin Panel (Phase 4) can now display contactSubmissions in admin dashboard
</output>
