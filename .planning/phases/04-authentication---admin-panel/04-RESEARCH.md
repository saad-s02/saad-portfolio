# Phase 4: Authentication & Admin Panel - Research

**Researched:** 2026-01-19
**Domain:** Authentication (WorkOS AuthKit) + Admin Dashboard with Convex Backend
**Confidence:** HIGH

## Summary

This phase integrates WorkOS AuthKit with Next.js App Router and Convex for secure admin-only access to portfolio content management. WorkOS provides first-class integration with Convex through the `@convex-dev/workos` package, eliminating token plumbing complexity. The architecture follows defense-in-depth: middleware protects routes, WorkOS manages sessions with encrypted cookies, and Convex mutations verify authentication at the data access layer.

The standard pattern uses email allowlisting through custom JWT templates in WorkOS dashboard, Next.js middleware for route protection, Server Actions for form submissions, and Convex mutations with `ctx.auth.getUserIdentity()` verification. Admin forms use react-hook-form with Zod validation and optimistic UI updates.

**Primary recommendation:** Use WorkOS AuthKit's official Convex integration (`@convex-dev/workos`) with email allowlist enforcement via custom JWT templates. Protect routes with Next.js middleware AND verify authentication in every Convex mutation (never rely solely on middleware due to CVE-2025-29927). Build admin forms with react-hook-form + Zod + Server Actions for type-safe, validated CRUD operations.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `@workos-inc/authkit-nextjs` | Latest (v1.x+) | WorkOS auth for Next.js App Router | Official WorkOS SDK with middleware helpers, session management, HTTP-only cookie encryption |
| `@convex-dev/workos` | Latest | WorkOS-Convex integration | Official integration package eliminating custom JWT config |
| `react-hook-form` | 7.x | Form state management | Industry standard for React forms, minimal re-renders, excellent TypeScript support |
| `zod` | 4.x | Schema validation | Type-safe validation with TypeScript inference, perfect for form validation + Server Actions |
| `@hookform/resolvers` | 5.x+ | RHF-Zod bridge | Connects Zod schemas to react-hook-form validation |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `react-hot-toast` | Already installed | User feedback | Already in project, use for success/error notifications in admin |
| Framer Motion | Already installed | Admin UI animations | Optional for admin transitions (dialogs, list items) |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| WorkOS AuthKit | Clerk, Auth0, NextAuth.js | WorkOS has official Convex integration (less config), but others work with custom JWT setup |
| react-hook-form | Formik, Tanstack Form | RHF has better performance (less re-renders) and stronger ecosystem |
| Zod | Yup, Joi | Zod's TypeScript inference is superior, better DX with type safety |

**Installation:**
```bash
npm install @workos-inc/authkit-nextjs @convex-dev/workos
# Form libraries already installed: react-hook-form @hookform/resolvers zod
```

## Architecture Patterns

### Recommended Project Structure
```
app/
├── admin/                    # Protected admin routes
│   ├── layout.tsx           # Admin shell (sidebar, auth check)
│   ├── page.tsx             # Dashboard overview
│   ├── projects/
│   │   ├── page.tsx         # Projects list (all statuses)
│   │   ├── new/
│   │   │   └── page.tsx     # Create project form
│   │   └── [id]/
│   │       └── edit/
│   │           └── page.tsx # Edit project form
│   ├── resume/
│   │   └── page.tsx         # Resume editor
│   └── changelog/
│       └── page.tsx         # Changelog visibility toggle
├── auth/
│   ├── callback/
│   │   └── route.ts         # OAuth callback handler
│   ├── sign-in/
│   │   └── route.ts         # Initiate sign-in flow
│   └── sign-out/
│       └── route.ts         # Sign-out handler
└── ConvexClientProvider.tsx # Wrap ConvexProviderWithAuth + AuthKitProvider

convex/
├── auth.config.ts           # WorkOS JWT validation config (auto-generated by @convex-dev/workos)
├── projects.ts              # Add admin queries/mutations
├── resume.ts                # Add admin mutations
├── changelog.ts             # Add admin queries/mutations
└── http.ts                  # Optional: WorkOS webhook handler for user sync

middleware.ts                # Route protection with authkitMiddleware
```

### Pattern 1: Defense-in-Depth Authentication
**What:** Verify authentication at multiple layers, never rely on middleware alone.
**When to use:** Always, for all authenticated operations.
**Example:**
```typescript
// middleware.ts - First line of defense
import { authkitMiddleware } from '@workos-inc/authkit-nextjs';
export default authkitMiddleware({
  middlewareAuth: {
    enabled: true,
    unauthenticatedPaths: ['/', '/about', '/resume', '/projects', '/projects/*', '/stack', '/contact'],
  },
});

// app/admin/layout.tsx - Second layer (UI redirect)
import { withAuth } from '@workos-inc/authkit-nextjs';
import { redirect } from 'next/navigation';

export default async function AdminLayout({ children }) {
  const { user } = await withAuth();

  // Email allowlist check (custom claim from JWT template)
  if (!user || !user.isAdmin) {
    redirect('/auth/sign-in');
  }

  return <AdminShell>{children}</AdminShell>;
}

// convex/projects.ts - Third layer (data access)
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const createProject = mutation({
  args: { /* project fields */ },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Unauthorized");
    }

    // Optional: additional allowlist check in Convex
    const adminEmail = process.env.ADMIN_EMAIL;
    if (identity.email !== adminEmail) {
      throw new Error("Forbidden");
    }

    return await ctx.db.insert("projects", args);
  },
});
```

### Pattern 2: Email Allowlist via JWT Custom Claims
**What:** Configure WorkOS to add custom `isAdmin` claim based on email allowlist.
**When to use:** Single or small set of admin emails (simpler than user management API).
**Example:**
```typescript
// WorkOS Dashboard → Authentication → Configure JWT Template
// Template (JSON):
{
  "email": "{{ user.email }}",
  "name": "{{ user.firstName }} {{ user.lastName }}",
  "isAdmin": {% if user.email in ["admin@example.com", "owner@example.com"] %}true{% else %}false{% endif %}
}

// Access in Next.js:
const { user } = await withAuth();
console.log(user.isAdmin); // true/false based on email

// Access in Convex:
const identity = await ctx.auth.getUserIdentity();
console.log(identity.isAdmin); // available in JWT claims
```

### Pattern 3: Form State with react-hook-form + Zod
**What:** Type-safe forms with schema validation and Server Actions.
**When to use:** All admin CRUD forms.
**Example:**
```typescript
// app/admin/projects/new/schema.ts
import { z } from 'zod';

export const projectSchema = z.object({
  title: z.string().min(1, "Title is required").max(200),
  slug: z.string().min(1).regex(/^[a-z0-9-]+$/, "Invalid slug format"),
  summary: z.string().min(1).max(500),
  content: z.string().min(1),
  status: z.enum(["draft", "published"]),
  featured: z.boolean(),
  stack: z.array(z.string()).min(1, "At least one tech stack item required"),
  tags: z.array(z.string()),
  links: z.array(z.object({
    label: z.string(),
    url: z.string().url(),
  })),
  screenshots: z.array(z.string().url()),
});

export type ProjectFormData = z.infer<typeof projectSchema>;

// app/admin/projects/new/actions.ts (Server Action)
'use server';
import { projectSchema } from './schema';
import { api } from '@/convex/_generated/api';
import { fetchMutation } from 'convex/nextjs';

export async function createProjectAction(formData: ProjectFormData) {
  // Validate with Zod
  const validated = projectSchema.parse(formData);

  // Call Convex mutation (auth verified in mutation)
  const projectId = await fetchMutation(api.projects.create, validated);

  return { success: true, projectId };
}

// app/admin/projects/new/ProjectForm.tsx (Client Component)
'use client';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { projectSchema, ProjectFormData } from './schema';
import { createProjectAction } from './actions';

export function ProjectForm() {
  const { register, handleSubmit, formState: { errors } } = useForm<ProjectFormData>({
    resolver: zodResolver(projectSchema),
    defaultValues: {
      status: "draft",
      featured: false,
      stack: [],
      tags: [],
      links: [],
      screenshots: [],
    },
  });

  const onSubmit = async (data: ProjectFormData) => {
    const result = await createProjectAction(data);
    // Handle result (redirect, toast, etc.)
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* Form fields with {...register("fieldName")} */}
      {/* Display errors.fieldName?.message */}
    </form>
  );
}
```

### Pattern 4: Optimistic UI Updates for Toggles
**What:** Immediately update UI before mutation completes for instant feedback.
**When to use:** Boolean toggles (draft/published, featured, changelog visibility).
**Example:**
```typescript
'use client';
import { useMutation } from 'convex/react';
import { api } from '@/convex/_generated/api';
import { useState } from 'react';

export function ProjectStatusToggle({ projectId, initialStatus }) {
  const [optimisticStatus, setOptimisticStatus] = useState(initialStatus);
  const updateStatus = useMutation(api.projects.updateStatus);

  const handleToggle = async () => {
    const newStatus = optimisticStatus === "draft" ? "published" : "draft";

    // Optimistic update
    setOptimisticStatus(newStatus);

    try {
      await updateStatus({ id: projectId, status: newStatus });
      toast.success(`Project ${newStatus}`);
    } catch (error) {
      // Rollback on error
      setOptimisticStatus(optimisticStatus);
      toast.error("Failed to update status");
    }
  };

  return (
    <button onClick={handleToggle}>
      {optimisticStatus === "published" ? "Unpublish" : "Publish"}
    </button>
  );
}
```

### Pattern 5: Delete Confirmation Dialog
**What:** Modal confirmation before destructive actions.
**When to use:** Delete operations, irreversible changes.
**Example:**
```typescript
'use client';
import { useState } from 'react';
import { useMutation } from 'convex/react';
import { api } from '@/convex/_generated/api';

export function DeleteProjectButton({ projectId, projectTitle }) {
  const [showConfirm, setShowConfirm] = useState(false);
  const deleteProject = useMutation(api.projects.remove);

  const handleDelete = async () => {
    try {
      await deleteProject({ id: projectId });
      toast.success("Project deleted");
      // Navigate away or refresh list
    } catch (error) {
      toast.error("Failed to delete project");
    } finally {
      setShowConfirm(false);
    }
  };

  return (
    <>
      <button onClick={() => setShowConfirm(true)} className="text-red-500">
        Delete
      </button>

      {showConfirm && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center">
          <div className="bg-gray-800 p-6 rounded-lg max-w-md">
            <h3 className="text-xl font-bold mb-2">Delete Project?</h3>
            <p className="text-gray-400 mb-4">
              Are you sure you want to delete "{projectTitle}"? This action cannot be undone.
            </p>
            <div className="flex gap-3 justify-end">
              <button
                onClick={() => setShowConfirm(false)}
                className="px-4 py-2 bg-gray-700 rounded"
              >
                Cancel
              </button>
              <button
                onClick={handleDelete}
                className="px-4 py-2 bg-red-600 rounded"
              >
                Delete
              </button>
            </div>
          </div>
        </div>
      )}
    </>
  );
}
```

### Anti-Patterns to Avoid
- **Middleware-only auth:** Never rely solely on middleware for security (CVE-2025-29927 bypass risk). Always verify in Convex mutations.
- **localStorage tokens:** Never store auth tokens in localStorage (XSS vulnerability). WorkOS uses HTTP-only cookies correctly.
- **Prop drilling user:** Don't pass user object through multiple components. Use `withAuth()` at layout level, verify in mutations.
- **Unvalidated Server Actions:** Always validate Server Action inputs with Zod, even if form has client-side validation.
- **Generic error messages:** Don't expose "Unauthorized" on admin pages without auth. Redirect immediately in layout.
- **No confirmation on delete:** Always confirm destructive actions, users expect safety checks.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Email allowlist logic | Custom user table + manual checks | WorkOS JWT custom claims | Handles edge cases (email case sensitivity, updates), centralized in dashboard |
| Session management | Custom JWT + refresh tokens | WorkOS AuthKit cookies | HTTP-only encryption, secure rotation, CSRF protection built-in |
| Form validation | Manual field-by-field checks | Zod schemas + zodResolver | Type inference, reusable schemas, consistent error format |
| CSRF protection for Server Actions | Custom token generation | Next.js built-in (POST + Origin check) | Server Actions have automatic CSRF via Origin header validation |
| Optimistic updates | Manual state tracking + rollback | React Query or local state pattern | Race conditions, concurrent updates, error recovery is complex |
| Route protection | Custom redirect logic in each page | Next.js middleware + layout checks | Centralized, runs before page render, better UX |

**Key insight:** Authentication infrastructure has subtle edge cases (session fixation, timing attacks, token rotation). Using battle-tested libraries like WorkOS prevents security vulnerabilities that emerge from custom implementations.

## Common Pitfalls

### Pitfall 1: CVE-2025-29927 Middleware Bypass
**What goes wrong:** Next.js middleware can be bypassed in certain edge cases, allowing unauthorized access even when middleware returns redirect.
**Why it happens:** Middleware runs on edge runtime with different request handling than origin server. Attackers can craft requests that skip middleware entirely.
**How to avoid:** ALWAYS verify authentication in Convex mutations with `ctx.auth.getUserIdentity()`. Treat middleware as UX optimization (fast redirect), not security boundary.
**Warning signs:** Admin mutations that only check "if user is signed in" without verifying allowlist. Relying on middleware config alone.

### Pitfall 2: JWT Template Size Limit
**What goes wrong:** WorkOS JWT templates have 3072-byte cookie size limit. Adding too many custom claims causes silent failures or truncated data.
**Why it happens:** HTTP cookies have browser size limits. JWT must fit in Set-Cookie header.
**How to avoid:** Keep JWT custom claims minimal. Only add `isAdmin: boolean`, not full user profiles. Store extended data in Convex users table.
**Warning signs:** Login works in dev but fails in production with many users. Custom claims not appearing in `getUserIdentity()`.

### Pitfall 3: Email Case Sensitivity in Allowlists
**What goes wrong:** User signs up with "Admin@Example.com" but allowlist checks for "admin@example.com". Access denied despite correct email.
**Why it happens:** Email comparison is case-sensitive in naive implementations.
**How to avoid:** Normalize emails to lowercase in JWT template: `{% if user.email | lower in ["admin@example.com"] %}`. Or use WorkOS user metadata API instead of JWT templates for allowlists.
**Warning signs:** Some users can't access admin despite being in allowlist. Works locally but fails in production.

### Pitfall 4: Stale Session After Permission Changes
**What goes wrong:** Admin removes user from allowlist, but user still has access for hours due to cached JWT.
**Why it happens:** JWTs are stateless and don't invalidate until expiration. WorkOS default session is 1 hour.
**How to avoid:** Document expected delay (up to 1 hour). For immediate revocation, implement server-side session check in Convex (query allowlist from DB, not just JWT). Or reduce JWT TTL in WorkOS dashboard.
**Warning signs:** Security requirement for "instant revocation" without understanding JWT statelessness.

### Pitfall 5: Draft Projects Leaking in Admin Queries
**What goes wrong:** Public queries filter drafts, but admin list query forgets filter. Draft projects appear on public pages due to caching.
**Why it happens:** Copy-paste query code without adjusting filters. Convex cache returns stale data.
**How to avoid:** Create separate queries for admin (all statuses) vs public (published only). Never reuse public queries in admin with "bypass" flags.
**Warning signs:** Draft projects briefly visible on homepage. Inconsistent filtering between pages.

### Pitfall 6: Server Actions Without Auth Context
**What goes wrong:** Server Action calls Convex mutation, but no auth token passed. Mutation fails with "Unauthorized" even though user is logged in.
**Why it happens:** `fetchMutation` from `convex/nextjs` doesn't automatically pass WorkOS token. Need custom fetch with auth headers.
**How to avoid:** Use `ConvexHttpClient` with auth token from `withAuth()`, or call mutations from client with `useMutation` hook (automatically authenticated).
**Warning signs:** Forms work in client components but fail in Server Actions. "No token provided" errors in Convex logs.

### Pitfall 7: Unvalidated Dynamic Segments
**What goes wrong:** `/admin/projects/[id]/edit` accepts any `id` string. Attacker passes `../../../../etc/passwd` or `undefined`. Server crashes or leaks data.
**Why it happens:** Dynamic route params are unvalidated user input. Trusting `params.id` without checks.
**How to avoid:** Validate dynamic params with Zod or type guard. Convex IDs follow specific format (check with `Id` type).
**Warning signs:** 500 errors on malformed URLs. Type errors in Convex queries with invalid IDs.

## Code Examples

Verified patterns from official sources:

### WorkOS AuthKit + Convex Integration Setup
```typescript
// Source: https://docs.convex.dev/auth/authkit/

// 1. Install packages
// npm install @workos-inc/authkit-nextjs @convex-dev/workos

// 2. Environment variables (.env.local)
WORKOS_CLIENT_ID=client_...
WORKOS_API_KEY=sk_live_...
WORKOS_COOKIE_PASSWORD=<generate with: openssl rand -base64 32>
NEXT_PUBLIC_WORKOS_REDIRECT_URI=http://localhost:3000/auth/callback
NEXT_PUBLIC_CONVEX_URL=https://your-deployment.convex.cloud
CONVEX_DEPLOY_KEY=...

// 3. Convex auth config (convex/auth.config.ts)
const clientId = process.env.WORKOS_CLIENT_ID;
export default {
  providers: [
    {
      type: "customJwt",
      issuer: "https://api.workos.com/",
      algorithm: "RS256",
      applicationID: clientId,
      jwks: `https://api.workos.com/sso/jwks/${clientId}`,
    },
    {
      type: "customJwt",
      issuer: `https://api.workos.com/user_management/${clientId}`,
      algorithm: "RS256",
      jwks: `https://api.workos.com/sso/jwks/${clientId}`,
    },
  ],
};

// 4. Middleware (middleware.ts)
import { authkitMiddleware } from '@workos-inc/authkit-nextjs';

export default authkitMiddleware({
  middlewareAuth: {
    enabled: true,
    unauthenticatedPaths: ['/', '/about', '/resume', '/projects', '/projects/*', '/stack', '/contact'],
  },
});

export const config = {
  matcher: ['/((?!_next|api|favicon.ico).*)'],
};

// 5. Auth routes
// app/auth/callback/route.ts
import { handleAuth } from '@workos-inc/authkit-nextjs';
export const GET = handleAuth();

// app/auth/sign-in/route.ts
import { getSignInUrl } from '@workos-inc/authkit-nextjs';
import { redirect } from 'next/navigation';
export const GET = async () => {
  const signInUrl = await getSignInUrl();
  redirect(signInUrl);
};

// app/auth/sign-out/route.ts
import { getSignOutUrl } from '@workos-inc/authkit-nextjs';
import { redirect } from 'next/navigation';
export const GET = async () => {
  const signOutUrl = await getSignOutUrl();
  redirect(signOutUrl);
};

// 6. Convex client provider (app/ConvexClientProvider.tsx)
'use client';
import { ConvexProviderWithAuth } from 'convex/react';
import { ConvexReactClient } from 'convex/react';
import { useAuth } from '@workos-inc/authkit-nextjs/use-auth';
import { AuthKitProvider } from '@workos-inc/authkit-nextjs';

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

export function ConvexClientProvider({ children }: { children: React.ReactNode }) {
  return (
    <AuthKitProvider>
      <ConvexProviderWithAuth client={convex} useAuth={useAuth}>
        {children}
      </ConvexProviderWithAuth>
    </AuthKitProvider>
  );
}

// 7. Update root layout (app/layout.tsx)
import { ConvexClientProvider } from './ConvexClientProvider';

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <ConvexClientProvider>
          {children}
        </ConvexClientProvider>
      </body>
    </html>
  );
}
```

### Authentication Verification in Convex Mutations
```typescript
// Source: https://docs.convex.dev/auth + https://stack.convex.dev/authorization

// convex/projects.ts
import { mutation, query } from "./_generated/server";
import { v } from "convex/values";

// Admin query: list ALL projects (including drafts)
export const listAll = query({
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Unauthorized");
    }

    // Optional: verify admin claim
    if (!identity.isAdmin) {
      throw new Error("Forbidden: Admin access required");
    }

    return await ctx.db.query("projects").collect();
  },
});

// Create project mutation
export const create = mutation({
  args: {
    title: v.string(),
    slug: v.string(),
    summary: v.string(),
    content: v.string(),
    status: v.union(v.literal("draft"), v.literal("published")),
    featured: v.boolean(),
    stack: v.array(v.string()),
    tags: v.array(v.string()),
    links: v.array(v.object({ label: v.string(), url: v.string() })),
    screenshots: v.array(v.string()),
  },
  handler: async (ctx, args) => {
    // CRITICAL: Verify auth before mutation
    const identity = await ctx.auth.getUserIdentity();
    if (!identity || !identity.isAdmin) {
      throw new Error("Unauthorized");
    }

    const projectId = await ctx.db.insert("projects", args);
    return projectId;
  },
});

// Update project mutation
export const update = mutation({
  args: {
    id: v.id("projects"),
    title: v.optional(v.string()),
    slug: v.optional(v.string()),
    summary: v.optional(v.string()),
    content: v.optional(v.string()),
    status: v.optional(v.union(v.literal("draft"), v.literal("published"))),
    featured: v.optional(v.boolean()),
    stack: v.optional(v.array(v.string())),
    tags: v.optional(v.array(v.string())),
    links: v.optional(v.array(v.object({ label: v.string(), url: v.string() }))),
    screenshots: v.optional(v.array(v.string())),
  },
  handler: async (ctx, { id, ...updates }) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity || !identity.isAdmin) {
      throw new Error("Unauthorized");
    }

    await ctx.db.patch(id, updates);
  },
});

// Delete project mutation
export const remove = mutation({
  args: { id: v.id("projects") },
  handler: async (ctx, { id }) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity || !identity.isAdmin) {
      throw new Error("Unauthorized");
    }

    await ctx.db.delete(id);
  },
});

// Quick status toggle mutation
export const updateStatus = mutation({
  args: {
    id: v.id("projects"),
    status: v.union(v.literal("draft"), v.literal("published")),
  },
  handler: async (ctx, { id, status }) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity || !identity.isAdmin) {
      throw new Error("Unauthorized");
    }

    await ctx.db.patch(id, { status });
  },
});

// Toggle featured flag
export const updateFeatured = mutation({
  args: {
    id: v.id("projects"),
    featured: v.boolean(),
  },
  handler: async (ctx, { id, featured }) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity || !identity.isAdmin) {
      throw new Error("Unauthorized");
    }

    await ctx.db.patch(id, { featured });
  },
});
```

### Admin Layout with Auth Check
```typescript
// Source: https://workos.com/docs/authkit/nextjs

// app/admin/layout.tsx
import { withAuth } from '@workos-inc/authkit-nextjs';
import { redirect } from 'next/navigation';
import Link from 'next/link';

export default async function AdminLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const { user } = await withAuth();

  // Redirect if not authenticated or not admin
  if (!user || !user.isAdmin) {
    redirect('/auth/sign-in');
  }

  return (
    <div className="min-h-screen bg-gray-950">
      <nav className="bg-gray-900 border-b border-gray-800">
        <div className="container mx-auto px-4 py-4">
          <div className="flex items-center justify-between">
            <h1 className="text-xl font-bold">Admin Panel</h1>
            <div className="flex items-center gap-6">
              <span className="text-sm text-gray-400">{user.email}</span>
              <a href="/auth/sign-out" className="text-sm text-red-400 hover:text-red-300">
                Sign Out
              </a>
            </div>
          </div>
        </div>
      </nav>

      <div className="container mx-auto px-4 py-8 flex gap-8">
        <aside className="w-64 shrink-0">
          <nav className="space-y-2">
            <Link
              href="/admin"
              className="block px-4 py-2 rounded bg-gray-800 hover:bg-gray-700"
            >
              Dashboard
            </Link>
            <Link
              href="/admin/projects"
              className="block px-4 py-2 rounded bg-gray-800 hover:bg-gray-700"
            >
              Projects
            </Link>
            <Link
              href="/admin/resume"
              className="block px-4 py-2 rounded bg-gray-800 hover:bg-700"
            >
              Resume
            </Link>
            <Link
              href="/admin/changelog"
              className="block px-4 py-2 rounded bg-gray-800 hover:bg-gray-700"
            >
              Changelog
            </Link>
          </nav>
        </aside>

        <main className="flex-1">{children}</main>
      </div>
    </div>
  );
}
```

### Admin Form with react-hook-form + Zod + Server Actions
```typescript
// Source: https://www.contentful.com/blog/react-hook-form-validation-zod/
// Source: https://nextjs.org/docs/app/guides/forms

// app/admin/projects/new/page.tsx
import { ProjectForm } from './ProjectForm';

export default function NewProjectPage() {
  return (
    <div>
      <h1 className="text-3xl font-bold mb-8">Create New Project</h1>
      <ProjectForm />
    </div>
  );
}

// app/admin/projects/new/schema.ts
import { z } from 'zod';

export const projectSchema = z.object({
  title: z.string().min(1, "Title is required").max(200),
  slug: z.string()
    .min(1, "Slug is required")
    .regex(/^[a-z0-9-]+$/, "Slug must be lowercase letters, numbers, and hyphens only"),
  summary: z.string().min(1, "Summary is required").max(500),
  content: z.string().min(1, "Content is required"),
  status: z.enum(["draft", "published"]),
  featured: z.boolean(),
  stack: z.array(z.string()).min(1, "At least one technology required"),
  tags: z.array(z.string()),
  links: z.array(z.object({
    label: z.string().min(1),
    url: z.string().url("Must be a valid URL"),
  })),
  screenshots: z.array(z.string().url("Must be a valid URL")),
});

export type ProjectFormData = z.infer<typeof projectSchema>;

// app/admin/projects/new/actions.ts
'use server';
import { api } from '@/convex/_generated/api';
import { fetchMutation } from 'convex/nextjs';
import { projectSchema, type ProjectFormData } from './schema';
import { withAuth } from '@workos-inc/authkit-nextjs';

export async function createProjectAction(formData: ProjectFormData) {
  // Double-check auth server-side
  const { user } = await withAuth();
  if (!user || !user.isAdmin) {
    throw new Error("Unauthorized");
  }

  // Validate with Zod
  const validated = projectSchema.parse(formData);

  // Create project via Convex (mutation will verify auth again)
  const projectId = await fetchMutation(api.projects.create, validated);

  return { success: true, projectId };
}

// app/admin/projects/new/ProjectForm.tsx
'use client';
import { useForm, useFieldArray } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { projectSchema, type ProjectFormData } from './schema';
import { createProjectAction } from './actions';
import { useRouter } from 'next/navigation';
import toast from 'react-hot-toast';

export function ProjectForm() {
  const router = useRouter();
  const {
    register,
    handleSubmit,
    control,
    formState: { errors, isSubmitting },
  } = useForm<ProjectFormData>({
    resolver: zodResolver(projectSchema),
    defaultValues: {
      status: "draft",
      featured: false,
      stack: [],
      tags: [],
      links: [],
      screenshots: [],
    },
  });

  const { fields: linkFields, append: appendLink, remove: removeLink } = useFieldArray({
    control,
    name: "links",
  });

  const onSubmit = async (data: ProjectFormData) => {
    try {
      const result = await createProjectAction(data);
      toast.success("Project created!");
      router.push('/admin/projects');
    } catch (error) {
      toast.error(error instanceof Error ? error.message : "Failed to create project");
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      {/* Title */}
      <div>
        <label htmlFor="title" className="block text-sm font-medium mb-2">
          Title
        </label>
        <input
          id="title"
          {...register("title")}
          className="w-full px-4 py-2 bg-gray-800 border border-gray-700 rounded"
        />
        {errors.title && (
          <p className="text-red-400 text-sm mt-1">{errors.title.message}</p>
        )}
      </div>

      {/* Slug */}
      <div>
        <label htmlFor="slug" className="block text-sm font-medium mb-2">
          Slug
        </label>
        <input
          id="slug"
          {...register("slug")}
          className="w-full px-4 py-2 bg-gray-800 border border-gray-700 rounded"
        />
        {errors.slug && (
          <p className="text-red-400 text-sm mt-1">{errors.slug.message}</p>
        )}
      </div>

      {/* Summary */}
      <div>
        <label htmlFor="summary" className="block text-sm font-medium mb-2">
          Summary
        </label>
        <textarea
          id="summary"
          {...register("summary")}
          rows={3}
          className="w-full px-4 py-2 bg-gray-800 border border-gray-700 rounded"
        />
        {errors.summary && (
          <p className="text-red-400 text-sm mt-1">{errors.summary.message}</p>
        )}
      </div>

      {/* Content */}
      <div>
        <label htmlFor="content" className="block text-sm font-medium mb-2">
          Content (Markdown)
        </label>
        <textarea
          id="content"
          {...register("content")}
          rows={12}
          className="w-full px-4 py-2 bg-gray-800 border border-gray-700 rounded font-mono text-sm"
        />
        {errors.content && (
          <p className="text-red-400 text-sm mt-1">{errors.content.message}</p>
        )}
      </div>

      {/* Status & Featured */}
      <div className="flex gap-6">
        <div>
          <label htmlFor="status" className="block text-sm font-medium mb-2">
            Status
          </label>
          <select
            id="status"
            {...register("status")}
            className="px-4 py-2 bg-gray-800 border border-gray-700 rounded"
          >
            <option value="draft">Draft</option>
            <option value="published">Published</option>
          </select>
        </div>

        <div className="flex items-center gap-2">
          <input
            id="featured"
            type="checkbox"
            {...register("featured")}
            className="w-4 h-4"
          />
          <label htmlFor="featured" className="text-sm font-medium">
            Featured
          </label>
        </div>
      </div>

      {/* Links (dynamic array) */}
      <div>
        <div className="flex items-center justify-between mb-2">
          <label className="block text-sm font-medium">Links</label>
          <button
            type="button"
            onClick={() => appendLink({ label: "", url: "" })}
            className="text-sm text-blue-400 hover:text-blue-300"
          >
            + Add Link
          </button>
        </div>
        <div className="space-y-3">
          {linkFields.map((field, index) => (
            <div key={field.id} className="flex gap-3">
              <input
                {...register(`links.${index}.label`)}
                placeholder="Label"
                className="flex-1 px-4 py-2 bg-gray-800 border border-gray-700 rounded"
              />
              <input
                {...register(`links.${index}.url`)}
                placeholder="URL"
                className="flex-1 px-4 py-2 bg-gray-800 border border-gray-700 rounded"
              />
              <button
                type="button"
                onClick={() => removeLink(index)}
                className="px-3 py-2 bg-red-600 rounded hover:bg-red-700"
              >
                Remove
              </button>
            </div>
          ))}
        </div>
      </div>

      {/* Submit */}
      <div className="flex gap-4">
        <button
          type="submit"
          disabled={isSubmitting}
          className="px-6 py-2 bg-blue-600 rounded hover:bg-blue-700 disabled:opacity-50"
        >
          {isSubmitting ? "Creating..." : "Create Project"}
        </button>
        <button
          type="button"
          onClick={() => router.back()}
          className="px-6 py-2 bg-gray-700 rounded hover:bg-gray-600"
        >
          Cancel
        </button>
      </div>
    </form>
  );
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Custom JWT configuration | WorkOS `@convex-dev/workos` package | Q4 2024 | Eliminates manual JWKS setup, auto-provisions config |
| NextAuth.js v4 | Auth.js (NextAuth v5) or WorkOS AuthKit | 2024 | Better App Router support, edge runtime compatibility |
| API routes for mutations | Next.js Server Actions | Next.js 13+ (2023) | Reduced boilerplate, automatic type safety, built-in CSRF |
| Formik | react-hook-form | 2020+ | Better performance (less re-renders), smaller bundle |
| Yup validation | Zod | 2022+ | Superior TypeScript inference, better DX |
| Manual middleware auth | authkitMiddleware composable | WorkOS v1.0 (2024) | Simplified config, better edge support |
| localStorage tokens | HTTP-only cookies | Always best practice, enforced by modern libs | XSS protection |

**Deprecated/outdated:**
- **NextAuth.js v4 (Pages Router):** Replaced by Auth.js with App Router support
- **Manual CSRF tokens in Server Actions:** Next.js handles automatically via Origin header check
- **getServerSideProps for auth checks:** Replaced by async Server Components with `withAuth()`
- **Custom JWT parsing:** Use auth provider SDKs (WorkOS, Clerk) that handle verification
- **Prop drilling auth state:** Use layout-level checks + mutation-level verification instead

## Open Questions

Things that couldn't be fully resolved:

1. **Email Allowlist Storage Location**
   - What we know: Can use WorkOS JWT custom claims (simpler) or WorkOS User Management API with custom metadata
   - What's unclear: Best practice for 1-3 admins vs 10+ admins. JWT template seems sufficient for small team.
   - Recommendation: Use JWT custom claims for initial implementation (hardcoded emails in template). Migrate to user metadata API if >5 admins or dynamic allowlist needed.

2. **Handling WorkOS Webhook Events**
   - What we know: WorkOS can send webhooks for user events (created, updated, deleted) to sync data
   - What's unclear: Whether webhooks are necessary for single-admin use case or only for multi-user orgs
   - Recommendation: Skip webhooks initially. User data from `getUserIdentity()` is sufficient. Add webhooks later if need to track "last login" or sync additional user metadata.

3. **Admin Session Timeout UX**
   - What we know: WorkOS default session is 1 hour, then user must re-authenticate
   - What's unclear: Whether 1 hour is too short for admin content editing (could lose work)
   - Recommendation: Test default 1-hour timeout. If too short, configure longer TTL in WorkOS dashboard. Add client-side "session expiring" warning + auto-save draft feature.

4. **Optimistic UI vs Immediate Consistency**
   - What we know: Convex supports optimistic updates, but admin operations may need confirmation of success
   - What's unclear: Which admin actions benefit from optimistic UI (toggles?) vs should wait for confirmation (creates, deletes?)
   - Recommendation: Use optimistic for toggles (status, featured, visibility). Wait for confirmation on creates/deletes/major edits with loading states.

## Sources

### Primary (HIGH confidence)
- [WorkOS AuthKit Next.js Documentation](https://workos.com/docs/authkit/nextjs) - Official integration guide
- [Convex & WorkOS AuthKit Integration](https://docs.convex.dev/auth/authkit/) - Official Convex documentation
- [Convex Authentication](https://docs.convex.dev/auth) - Core auth concepts
- [WorkOS AuthKit GitHub Repository](https://github.com/workos/authkit-nextjs) - Source code and examples
- [Next.js Middleware Authentication](https://nextjs.org/docs/app/guides/authentication) - Official patterns
- [Next.js Server Actions Security](https://nextjs.org/blog/security-nextjs-server-components-actions) - Security model

### Secondary (MEDIUM confidence)
- [Complete Authentication Guide for Next.js App Router 2025](https://clerk.com/articles/complete-authentication-guide-for-nextjs-app-router) - General auth patterns
- [Authorization Best Practices](https://stack.convex.dev/authorization) - Convex blog on security
- [Authentication Best Practices: Convex, Clerk and Next.js](https://stack.convex.dev/authentication-best-practices-convex-clerk-and-nextjs) - Defense-in-depth patterns
- [React Hook Form Validation with Zod](https://www.contentful.com/blog/react-hook-form-validation-zod/) - Form patterns
- [Next.js Forms with Server Actions](https://nextjs.org/docs/app/guides/forms) - Official guide
- [Next.js Security Guide 2025](https://www.turbostarter.dev/blog/complete-nextjs-security-guide-2025-authentication-api-protection-and-best-practices) - Security checklist

### Tertiary (LOW confidence)
- [WorkOS Convex Integration Announcement](https://workos.com/blog/convex-typescript-workos-auth) - Marketing/overview
- [React Admin Dashboard Templates 2026](https://nextjstemplates.com/blog/admin-dashboard-templates) - UI inspiration
- [Next.js Admin Dashboard with RBAC](https://eastondev.com/blog/en/posts/dev/20260107-nextjs-rbac-admin-guide/) - Advanced patterns (may be overkill)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries have official docs, recent updates, active maintenance
- Architecture: HIGH - Patterns from official WorkOS + Convex documentation, verified code examples
- Pitfalls: MEDIUM-HIGH - CVE-2025-29927 is documented, other pitfalls inferred from docs + common issues
- Email allowlist: MEDIUM - JWT custom claims documented, but best practices for small teams less explicit
- Admin UI patterns: MEDIUM - React-hook-form + Zod are standard, but specific admin layout choices are conventional

**Research date:** 2026-01-19
**Valid until:** 30 days (stable stack, unlikely to change before Phase 4 completion)
